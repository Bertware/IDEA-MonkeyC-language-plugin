{
  parserClass="ee.edio.garmin.parser.MonkeyCParser"
  parserUtilClass="ee.edio.garmin.parser.MonkeyCParserUtil"

  implements="ee.edio.garmin.psi.MonkeyCPsiCompositeElement"
  extends="ee.edio.garmin.psi.impl.MonkeyCPsiCompositeElementImpl"

  elementTypeHolderClass="ee.edio.garmin.psi.MonkeyCTypes"
  elementTypePrefix=""
  elementTypeClass="ee.edio.garmin.psi.MonkeyCElementType"
  tokenTypeClass="ee.edio.garmin.psi.MonkeyCTokenType"

  psiClassPrefix="MonkeyC"
  psiImplClassSuffix="Impl"
  psiPackage="ee.edio.garmin.psi"
  psiImplPackage="ee.edio.garmin.psi.impl"
  psiImplUtilClass="ee.edio.garmin.psi.impl.MonkeyCPsiImplUtil"

tokens = [
    DOT = "."
    SEMI = ";"
    QUES = "?"
    COLON = ":"
    CLASS = "class"
    FUNCTION = "function"
    RETURN = "return"
    NEW = "new"
    VAR = "var"
    CONST = "const"
    MODULE = "module"
    USING = "using"
    AS = "as"
    ENUM = "enum"
    EXTENDS = "extends"
    NULL = "null"
    NATIVE = "native"
    HIDDEN = "hidden"
    STATIC = "static"
    INSTANCEOF = "instanceof"
    HAS = "has"
    IF = "if"
    ELSE = "else"
    DO = "do"
    WHILE = "while"
    FOR = "for"
    BREAK = "break"
    CONTINUE = "continue"
    SWITCH = "switch"
    DEFAULT = "default"
    CASE = "case"
    TRY = "try"
    CATCH = "catch"
    FINALLY = "finally"
    THROW = "throw"
    AND = "and"
    OR = "or"
    TRUE = "true"
    FALSE = "false"
    //SINGLE_LINE_COMMENT = "//"
    MULTI_LINE_COMMENT_START = "/*"
    MULTI_LINE_COMMENT_END = "*/"
    STRING_A = "\""
    STRING_B = "\'"

    LBRACE = "{"
    RBRACE = "}"

    LBRACKET = "["
    RBRACKET = "]"

    LPAREN = "("
    RPAREN = ")"
    COMMA = ","
    STAR = "*"
    BAR = "|"
    LT = "<"
    GT = ">"

    BARBAR = "||"
    AMPAMP = "&&"
    PLUSPLUS = "++"
    SUBSUB = "--"
    EQ = "="

    EQEQ = "=="
    BANGEQ = "!="
    PLUSEQ = "+="
    SUBEQ = "-="
    STAREQ = "*="
    SLASHEQ = "/="
    AMPEQ = "&="
    CARETEQ = "|="
    PERCENTEQ = "%="

    CARET = "^"
    PERCENT = "%"
    TILDE = "~"
    BANG = "!"

    OP_PLUS = "+"
    OP_MINUS = "-"
    OP_MULTIPLY = "*"
    OP_DIVIDE = "/"

    // WHITE_SPACE is overwritten by JFlex, this here is only for Live Preview
    WHITE_SPACE='regexp:\s+'

    SINGLE_LINE_COMMENT='regexp://.*'
    BLOCK_COMMENT='regexp:/\*([^*]|\*+[^*/])*(\*+/)?'

    //number='regexp:\d+(\.\d*)?'
    //alphanum='regexp:\p{Alpha}\w*'
    //string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"

    //symbol='regexp:\:\p{Alpha}\w*'

// alpha = letters

    // a letter following by X letters or numbers, where 0 <= X <= 30
    // [_a-zA-Z][_a-zA-Z0-9]{0,30}

    IDENTIFIER = 'regexp:[a-zA-Z0-9$_]*'

    INTEGER = 'regexp:\d+'
    NUMBER = 'regexp:\d+(\.\d*)?'
    STRINGLITERAL = "regexp:(\"([^\"\\]|\\.)*\")"
    CHARLITERAL = "regexp:('([^'\\]|\\.)*')"

    //JavaLetter='regexp:[a-zA-Z$_]' // these are the "java letters" below 0xFF'
    //JavaLetterOrDigit='regexp:[a-zA-Z0-9$_]'

  ]


  // extends(".*Expression")="expression"
}



monkeyCFile ::= compilationUnit

private compilationUnit ::= usingDeclaration* typeDeclaration*

usingDeclaration ::= USING IDENTIFIER (DOT IDENTIFIER)+ (AS IDENTIFIER)? SEMI

typeDeclaration ::= classDeclaration | SEMI

classDeclaration ::= normalClassDeclaration | enumDeclaration

normalClassDeclaration ::= modifiers CLASS IDENTIFIER (EXTENDS type)? classBody

modifiers ::= (STATIC)*

enumDeclaration ::= modifiers (ENUM) IDENTIFIER enumBody

enumBody ::= LBRACE (enumConstants)?
             COMMA? (enumBodyDeclarations)? RBRACE

enumConstants ::= enumConstant (COMMA enumConstant)*

/* TODO: $GScope::name = names.empty. enum constant body is actually
 an anonymous class, where constructor isn't allowed, have to add this check */
enumConstant ::= IDENTIFIER (arguments)? (classBody)?

enumBodyDeclarations ::= SEMI classBodyDeclaration*

classBody ::= LBRACE classBodyDeclaration* RBRACE

classBodyDeclaration ::= SEMI | (STATIC)? block | memberDecl

memberDecl ::= fieldDeclaration | functionDeclaration | classDeclaration

functionDeclaration ::= FUNCTION IDENTIFIER formalParameters (THROWS qualifiedNameList)?
                        LBRACE (explicitConstructorInvocation)? (blockStatement)* RBRACE

fieldDeclaration ::= modifiers type variableDeclarator
                    (COMMA variableDeclarator)* SEMI

variableDeclarator ::= IDENTIFIER (LBRACKET RBRACKET)* (EQ variableInitializer)?

type ::= classOrInterfaceType (LBRACKET RBRACKET)*
       | primitiveType (LBRACKET RBRACKET)*

classOrInterfaceType ::= IDENTIFIER (DOT IDENTIFIER)*

primitiveType ::= BOOLEAN
                | CHAR
                | BYTE
                | SHORT
                | INT
                | LONG
                | FLOAT
                | DOUBLE

qualifiedNameList ::= qualifiedName (COMMA qualifiedName)*

formalParameters ::= LPAREN (formalParameterDecls)? RPAREN

formalParameterDecls ::= normalParameterDecl (COMMA normalParameterDecl)*

normalParameterDecl ::= IDENTIFIER (LBRACKET RBRACKET)*

//NOTE: the position of Identifier 'super' is set to the type args position here
explicitConstructorInvocation ::= SUPER arguments SEMI
                                | primary DOT SUPER arguments SEMI

qualifiedName ::= IDENTIFIER (DOT IDENTIFIER)*

elementValue ::= conditionalExpression | elementValueArrayInitializer

elementValueArrayInitializer ::= LBRACE ( elementValue (COMMA elementValue)* )? (COMMA)? RBRACE
                               | LBRACKET ( elementValue (COMMA elementValue)* )? RBRACKET

block ::= LBRACE (blockStatement)* RBRACE

blockStatement ::= localVariableDeclarationStatement
                 | classDeclaration
                 | statement

localVariableDeclarationStatement ::= localVariableDeclaration SEMI

localVariableDeclaration ::= VAR variableDeclarator (COMMA variableDeclarator)*

statement ::= block
            | IF parExpression statement (ELSE statement)?
            | forStatement
            | WHILE parExpression statement
            | DO statement WHILE parExpression SEMI
            | tryStatement
            | SWITCH parExpression LBRACE switchBlockStatementGroups RBRACE
            | RETURN expression? SEMI
            | THROW expression SEMI
            | BREAK IDENTIFIER? SEMI
            | CONTINUE IDENTIFIER? SEMI
            | expression SEMI
            | IDENTIFIER COLON statement
            | SEMI

switchBlockStatementGroups ::= (switchBlockStatementGroup)*

switchBlockStatementGroup ::= switchLabel (blockStatement)*

switchLabel ::= CASE expression COLON | DEFAULT COLON

tryStatement ::= TRY block (catches FINALLY block | catches | FINALLY block)

catches ::= catchClause (catchClause)*

catchClause ::= CATCH LPAREN catchParameter RPAREN block

catchParameter ::= IDENTIFIER (LBRACKET RBRACKET)*

forStatement ::= // enhanced for loop
        FOR LPAREN VAR IDENTIFIER COLON expression RPAREN statement
        // normal for loop
        | FOR LPAREN (forInit)? SEMI (expression)? SEMI (expressionList)? RPAREN statement

forInit ::= localVariableDeclaration| expressionList

parExpression ::= LPAREN expression RPAREN

expressionList ::= expression (COMMA expression)*

expression ::= conditionalExpression (assignmentOperator expression)?

assignmentOperator ::= EQ
                     | PLUSEQ
                     | SUBEQ
                     | STAREQ
                     | SLASHEQ
                     | AMPEQ
                     | BAREQ
                     | CARETEQ
                     | PERCENTEQ
                     | LT LT EQ
                     | GT GT GT EQ
                     | GT GT EQ

conditionalExpression ::= conditionalOrExpression (QUES expression COLON conditionalExpression)?

conditionalOrExpression ::= conditionalAndExpression (BARBAR conditionalAndExpression)*

conditionalAndExpression ::= inclusiveOrExpression (AMPAMP inclusiveOrExpression)*

inclusiveOrExpression ::= exclusiveOrExpression (BAR exclusiveOrExpression)*

exclusiveOrExpression ::= andExpression (CARET andExpression)*

andExpression ::= equalityExpression (AMP equalityExpression)*

equalityExpression ::= instanceOfExpression ((EQEQ | BANGEQ) instanceOfExpression)*

instanceOfExpression ::= relationalExpression (INSTANCEOF type)?

relationalExpression ::= shiftExpression (relationalOp shiftExpression)*

relationalOp ::= LT EQ | GT EQ | LT | GT

shiftExpression ::= additiveExpression (shiftOp additiveExpression)*

shiftOp ::= LT LT | GT GT GT | GT GT

additiveExpression ::= multiplicativeExpression ((PLUS | SUB) multiplicativeExpression)*

multiplicativeExpression ::= unaryExpression ((STAR | SLASH | PERCENT) unaryExpression)*

/**
 * NOTE: for '+' and '-', if the next token is int or long interal, then it's not a unary expression.
 *       it's a literal with signed value. INTLTERAL AND LONG LITERAL are added here for this.
 */
unaryExpression ::= PLUS unaryExpression
                  | SUB unaryExpression
                  | PLUSPLUS unaryExpression
                  | SUBSUB unaryExpression
                  | unaryExpressionNotPlusMinus

unaryExpressionNotPlusMinus ::= TILDE unaryExpression
                              | BANG unaryExpression
                              | primary (selector)* (PLUSPLUS | SUBSUB)?

/**
 * have to use scope here, parameter passing isn't well supported in antlr.
 */
primary ::= parExpression
          | IDENTIFIER (DOT IDENTIFIER)* (identifierSuffix)?
          | literal
          | creator
          | primitiveType (LBRACKET RBRACKET)* DOT CLASS
          | VOID DOT CLASS

identifierSuffix ::= (LBRACKET RBRACKET) + DOT CLASS
                   | (LBRACKET expression RBRACKET)+
                   | arguments
                   | DOT CLASS
                   | DOT IDENTIFIER arguments
                   | DOT SUPER arguments

selector ::= DOT IDENTIFIER (arguments)?
           | LBRACKET expression RBRACKET

creator ::= NEW classOrInterfaceType classCreatorRest | arrayCreator

arrayCreator ::= NEW createdName LBRACKET RBRACKET (LBRACKET RBRACKET)* arrayInitializer
               | NEW createdName LBRACKET expression RBRACKET (LBRACKET expression RBRACKET)* (LBRACKET RBRACKET)*
               | newArrayInitializer

newArrayInitializer ::= LBRACKET (variableInitializer (COMMA variableInitializer)*)? (COMMA)? RBRACKET

arrayInitializer ::= LBRACE (variableInitializer (COMMA variableInitializer)*)? (COMMA)? RBRACE

variableInitializer ::= arrayInitializer | expression

createdName ::= classOrInterfaceType | primitiveType

classCreatorRest ::= arguments (classBody)?

arguments ::= LPAREN (expressionList)? RPAREN

literal ::= INTLITERAL
          | LONGLITERAL
          | FLOATLITERAL
          | DOUBLELITERAL
          | CHARLITERAL
          | STRINGLITERAL
          | TRUE
          | FALSE
          | NULL

INTLITERAL ::= INTEGER
LONGLITERAL ::= INTEGER ('l' | 'L')
FLOATLITERAL ::= NUMBER ('f' | 'F')
DOUBLELITERAL ::= NUMBER ('d' | 'D')